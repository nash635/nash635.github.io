[{"title":"HCCL Deep Dive","path":"/2025/10/26/HCCL-Deep-Dive/","content":"HCCL (Huawei Collective Communication Library) 设计文档1. 项目概述1.1 项目简介HCCL（Huawei Collective Communication Library，华为集合通信库）是基于昇腾AI处理器的高性能集合通信库，为单机多卡及多机多卡环境提供高效的数据并行和模型并行集合通信方案。 开源代码库：https://gitee.com/ascend/cann-hccl 版本信息： 配套CANN软件版本发行 许可证： CANN Open Software License Agreement Version 1.0 1.2 核心特性 ✅ 高性能通信算法：支持9种拓扑算法（Mesh、Ring、RHD、PairWise、Star、NHR、NB、AHC、Pipeline） ✅ 灵活的通信模式：支持单机多卡和多机多卡场景 ✅ 智能算法选择：根据通信域信息和数据量自动选择最优算法 ✅ 分层网络优化：支持Server内和Server间分级通信 ✅ 多种集合操作：AllReduce、AllGather、ReduceScatter、Broadcast等 1.3 系统架构graph TB subgraph 适配层 A[图引擎适配] -- B[单算子适配] B -- C[通信切分优化] end subgraph 集合通信业务层 D[通信框架模块] E[通信算法模块] D -- D1[通信域管理] D -- D2[算子业务串联] D -- D3[算法选择] D -- D4[资源申请] D -- D5[任务下发] E -- E1[Mesh算法] E -- E2[Ring算法] E -- E3[RHD算法] E -- E4[PairWise算法] E -- E5[Star算法] E -- E6[NHR算法] E -- E7[NB算法] E -- E8[AHC算法] E -- E9[Pipeline算法] end subgraph 集合通信平台层 F[资源抽象] G[维测能力] end C -- D D -- E D -- F F -- G style D fill:#e1d5e7 style E fill:#e1d5e7 style D1 fill:#fff2cc style D2 fill:#fff2cc style D3 fill:#fff2cc style D4 fill:#fff2cc style D5 fill:#fff2cc 2. 核心架构设计2.1 三层架构模型HCCL采用分层设计，从上到下分为三个核心层次： graph LR A[适配层] -- B[业务层] B -- C[平台层] subgraph 本源码仓实现范围 B1[通信框架] B2[通信算法] end B -.包含.- B1 B -.包含.- B2 style B1 fill:#e1d5e7 style B2 fill:#e1d5e7 2.1.1 适配层职责： 图引擎与单算子的对接适配 通信操作的切分与优化 任务分发策略制定 2.1.2 集合通信业务层（本仓核心）通信框架模块： 通信域（Communicator）生命周期管理 集合通信算子的业务流程编排 算法选择策略与调度 与平台层协作完成资源申请 任务下发与执行管理 通信算法模块： 实现9种核心集合通信算法 资源消耗计算与评估 基于通信域信息的任务编排 算法性能模型（α-β模型）实现 2.1.3 集合通信平台层职责： NPU硬件资源抽象与管理 HCCS链路资源管理 通信日志与性能监控 错误诊断与恢复机制 2.2 目录结构cann-hccl/├── src/domain/collective_communication/│ ├── algorithm/ # 通信算法实现│ └── framework/ # 通信框架实现├── inc/hccl/ # 对外头文件│ ├── hccl.h│ └── hccl_types.h├── docs/ # 算法原理文档├── test/ # 测试代码├── cmake/ # 编译配置└── build.sh # 编译脚本 3. 集合通信算法详解HCCL的核心竞争力在于其丰富的集合通信算法库，针对不同的网络拓扑、节点规模和数据量提供最优解决方案。 3.1 性能评估模型HCCL采用 α-β模型（Hockney模型） 进行性能评估： $$T \\alpha + n\\beta + n\\gamma$$ 参数说明： α：节点间的固定时延（启动开销） β：每byte数据传输耗时（带宽倒数） n：通信数据大小（bytes） γ：每byte数据规约计算耗时 p：通信域节点个数 3.2 Mesh 算法3.2.1 算法原理graph LR N0((Rank0)) ---|全连接| N1((Rank1)) N0 ---|全连接| N2((Rank2)) N0 ---|全连接| N3((Rank3)) N1 ---|全连接| N2 N1 ---|全连接| N3 N2 ---|全连接| N3 style N0 fill:#ffcccc style N1 fill:#ccffcc style N2 fill:#ccccff style N3 fill:#ffffcc 特点： 拓扑： FullMesh互联，NPU间全连接 时间复杂度： O(1) 适用场景： Server内通信，小规模集群 优势： 一步完成通信，延迟最低 劣势： 资源开销大，难以扩展到大规模 3.2.2 执行流程示例（以AllReduce为例）说明： Mesh算法支持所有集合通信原语（AllReduce、AllGather、ReduceScatter、Broadcast、Reduce、Scatter、Gather等），此处以AllReduce为典型示例展示执行流程。 sequenceDiagram participant R0 as Rank0 participant R1 as Rank1 participant R2 as Rank2 participant R3 as Rank3 Note over R0,R3: Phase 1: ReduceScatter (并发) Note over R0,R3: 每个节点将数据切分为p份，并发发送给所有其他节点 R0-R1: 发送chunk_1 R0-R2: 发送chunk_2 R0-R3: 发送chunk_3 R1-R0: 发送chunk_0 R1-R2: 发送chunk_2 R1-R3: 发送chunk_3 R2-R0: 发送chunk_0 R2-R1: 发送chunk_1 R2-R3: 发送chunk_3 R3-R0: 发送chunk_0 R3-R1: 发送chunk_1 R3-R2: 发送chunk_2 Note over R0,R3: Phase 2: 本地Reduce Note over R0: 规约chunk_0 Note over R1: 规约chunk_1 Note over R2: 规约chunk_2 Note over R3: 规约chunk_3 Note over R0,R3: Phase 3: AllGather (并发) Note over R0,R3: 每个节点并发向所有其他节点发送自己的规约结果 R0-R1: 广播chunk_0* R0-R2: 广播chunk_0* R0-R3: 广播chunk_0* R1-R0: 广播chunk_1* R1-R2: 广播chunk_1* R1-R3: 广播chunk_1* R2-R0: 广播chunk_2* R2-R1: 广播chunk_2* R2-R3: 广播chunk_2* R3-R0: 广播chunk_3* R3-R1: 广播chunk_3* R3-R2: 广播chunk_3* Note over R0,R3: 所有节点持有完整规约结果 执行流程详细描述： Phase 1: ReduceScatter（并发执行） 数据准备: 每个节点将自己的n字节数据切分为p个chunk，每个chunk大小为np字节 并发发送: Rank0保留chunk_0，将chunk_1发送给Rank1，chunk_2发送给Rank2，chunk_3发送给Rank3 Rank1保留chunk_1，将chunk_0发送给Rank0，chunk_2发送给Rank2，chunk_3发送给Rank3 Rank2保留chunk_2，将chunk_0发送给Rank0，chunk_1发送给Rank1，chunk_3发送给Rank3 Rank3保留chunk_3，将chunk_0发送给Rank0，chunk_1发送给Rank1，chunk_2发送给Rank2 通信特点: 全连接并发，所有通信同时进行，利用FullMesh拓扑的双向带宽 Phase 2: 本地Reduce（本地计算） Rank0对接收到的所有chunk_0进行规约：chunk_0* chunk_0(R0) + chunk_0(R1) + chunk_0(R2) + chunk_0(R3) Rank1对接收到的所有chunk_1进行规约：chunk_1* chunk_1(R0) + chunk_1(R1) + chunk_1(R2) + chunk_1(R3) Rank2对接收到的所有chunk_2进行规约：chunk_2* chunk_2(R0) + chunk_2(R1) + chunk_2(R2) + chunk_2(R3) Rank3对接收到的所有chunk_3进行规约：chunk_3* chunk_3(R0) + chunk_3(R1) + chunk_3(R2) + chunk_3(R3) 此时每个节点持有1p的完整规约结果 Phase 3: AllGather（并发执行） 并发广播: Rank0将chunk_0*并发发送给Rank1, Rank2, Rank3 Rank1将chunk_1*并发发送给Rank0, Rank2, Rank3 Rank2将chunk_2*并发发送给Rank0, Rank1, Rank3 Rank3将chunk_3*并发发送给Rank0, Rank1, Rank2 最终状态: 所有节点持有完整的规约结果[chunk_0*, chunk_1*, chunk_2*, chunk_3*] 通信特点: 全连接并发，充分利用FullMesh拓扑的所有链路 其他原语： AllGather: 直接执行Phase 3（并发收集所有节点数据） ReduceScatter: 执行Phase 1 + Phase 2（并发规约后分散） Broadcast: 根节点向所有节点并发发送完整数据 Gather: 所有节点向根节点并发发送数据 3.2.3 性能模型 操作 耗时公式 说明 Scatter $\\alpha + \\frac{1}{p}n\\beta$ 一步完成，根节点向p个节点并发发送，每节点接收np数据 Gather $\\alpha + \\frac{1}{p}n\\beta$ 一步完成，p个节点向根节点并发发送，根节点接收全部数据 Broadcast $2\\alpha + \\frac{2}{p}n\\beta$ Scatter + AllGather实现（两步），每步传输部分数据 Reduce $2\\alpha + \\frac{2}{p}n\\beta + \\frac{p-1}{p}n\\gamma$ ReduceScatter + Gather实现，需规约所有输入数据 ReduceScatter $\\alpha + \\frac{1}{p}n\\beta + \\frac{p-1}{p}n\\gamma$ 一步完成，并发规约并分发，每节点接收np结果 AllGather $\\alpha + \\frac{1}{p}n\\beta$ 一步完成，全连接并发传输，每节点发送np数据 AllReduce $2\\alpha + \\frac{2}{p}n\\beta + \\frac{p-1}{p}n\\gamma$ ReduceScatter + AllGather两阶段，总共两步通信 3.3 Ring 算法3.3.1 算法原理graph LR R0((Rank0)) --|右手卡| R1((Rank1)) R1 --|右手卡| R2((Rank2)) R2 --|右手卡| R3((Rank3)) R3 --|右手卡| R0 R0 -.-|左手卡| R3 R1 -.-|左手卡| R0 R2 -.-|左手卡| R1 R3 -.-|左手卡| R2 style R0 fill:#ffcccc style R1 fill:#ccffcc style R2 fill:#ccccff style R3 fill:#ffffcc 特点： 拓扑： 环形结构，每个节点只与左右邻居通信 时间复杂度： O(p-1) - 线性复杂度 适用场景： Server内和Server间通信 小规模集群或小数据量 网络拥塞场景 Pipeline不适用的场景 3.3.2 执行流程示例（以AllReduce为例）说明： Ring算法支持多种集合通信原语（AllReduce、AllGather、ReduceScatter、Broadcast、Reduce、Scatter、Gather等），此处以AllReduce为典型示例展示执行流程。 两阶段概览graph TB subgraph 阶段1: ReduceScatter (p-1步) A1[数据切分为p块] -- A2[沿环传输并规约] A2 -- A3[每个节点持有1/p规约结果] end subgraph 阶段2: AllGather (p-1步) B1[每个节点持有1/p数据] -- B2[沿环传输完整数据] B2 -- B3[所有节点获得完整结果] end A3 -- B1 详细执行步骤（4节点示例）阶段1: ReduceScatter（p-13步完成） Ring算法的ReduceScatter阶段：每个节点在每一步都向右邻居发送一个数据块，并接收左邻居的数据块进行规约。经过p-1步后，每个节点持有一个完整规约的数据块。 sequenceDiagram participant R0 as Rank0br/[A0,B0,C0,D0] participant R1 as Rank1br/[A1,B1,C1,D1] participant R2 as Rank2br/[A2,B2,C2,D2] participant R3 as Rank3br/[A3,B3,C3,D3] Note over R0,R3: Step 1: 每个节点向右发送一个块 R0-R1: D0 R1-R2: D1 R2-R3: D2 R3-R0: D3 Note over R0: 接收D3，持有[A0,B0,C0,D0+D3] Note over R1: 接收D0，持有[A1,B1,C1,D0+D1] Note over R2: 接收D1，持有[A2,B2,C2+D1,D2] Note over R3: 接收D2，持有[A3+D2,B3,C3,D3] Note over R0,R3: Step 2: 继续向右发送刚规约的块 R0-R1: C0 R1-R2: D0+D1 R2-R3: C2+D1 R3-R0: D2+D3 Note over R0: 接收D2+D3，持有[A0,B0,C0,D*] Note over R1: 接收C0，持有[A1,B1,C0+C1,D*] Note over R2: 接收D0+D1，持有[A2,B2,C*,D*] Note over R3: 接收C2+D1，持有[A*,B3,C*,D3] Note over R0,R3: Step 3: 最后一轮 R0-R1: B0 R1-R2: C0+C1 R2-R3: B2 R3-R0: C* Note over R0: 接收C*，持有[A0,B0,C*,D*] Note over R1: 接收B0，持有[A1,B0+B1,C*,D*] Note over R2: 接收C0+C1，持有[A2,B*,C*,D2] Note over R3: 接收B2，持有[A3,B2+B3,C3,D*] 注意： 上述简化示例未完整展示。实际上ReduceScatter需要p-13步，每步每个节点都在某个特定位置进行规约。最终： Rank0持有A块的完整规约结果A* Rank1持有B块的完整规约结果B* Rank2持有C块的完整规约结果C* Rank3持有D块的完整规约结果D* 阶段2: AllGather（3步完成） sequenceDiagram participant R0 as Rank0 participant R1 as Rank1 participant R2 as Rank2 participant R3 as Rank3 Note over R0,R3: 每个节点持有1/4规约结果 Note over R0: [A*,B*,-,-] Note over R1: [-,B*,C*,-] Note over R2: [-,-,C*,D*] Note over R3: [A*,-,-,D*] Note over R0,R3: Step 1: 沿环传输收集 R0-R1: A* R1-R2: B* R2-R3: C* R3-R0: D* Note over R0,R3: Step 2: 继续传输 R0-R1: D* R1-R2: A* R2-R3: B* R3-R0: C* Note over R0,R3: Step 3: 最后一轮 R0-R1: C* R1-R2: D* R2-R3: A* R3-R0: B* Note over R0,R3: 所有节点持有完整结果[A*,B*,C*,D*] 执行流程详细描述： 阶段1: ReduceScatter（p-13步完成） Ring算法的核心思想：数据切分为p块，每个节点在每一步向右邻居发送一个块，从左邻居接收一个块并规约。经过p-1步后，每个节点持有一个完整规约的数据块。 初始状态: Rank0持有[A0, B0, C0, D0] Rank1持有[A1, B1, C1, D1] Rank2持有[A2, B2, C2, D2] Rank3持有[A3, B3, C3, D3] Step 1: 发送：R0→D0→R1, R1→D1→R2, R2→D2→R3, R3→D3→R0 规约：每个节点将接收的D块与本地D块规约 结果：R0持有D0+D3, R1持有D0+D1, R2持有D1+D2, R3持有D2+D3 数据流向：环形顺时针流动 Step 2: 发送：R0→C0→R1, R1→(D0+D1)→R2, R2→(C2+D1)→R3, R3→(D2+D3)→R0 规约：每个节点将接收的块与本地对应块规约 关键：R2完成D块的完整规约D* D0+D1+D2+D3 数据流向：继续顺时针，规约块逐步完成","tags":["HCCL","集合通信","算法","深度学习"],"categories":["技术","分布式通信"]},{"title":"博客搭建记录：从零到一的 Hexo + Stellar 实践","path":"/2025/07/24/hexo-stellar-blog-setup/","content":"博客搭建记录：从零到一的 Hexo + Stellar 实践作为一名技术人员，拥有一个个人博客来记录学习心得和分享技术经验是很有必要的。经过调研和实践，我最终选择了 Hexo + Stellar 主题的技术栈来搭建这个博客。 🎯 技术选型为什么选择 Hexo？在众多静态博客生成器中，我选择 Hexo 的原因： 生态丰富: 插件众多，扩展性强 中文友好: 中文文档完善，社区活跃 性能优秀: 生成速度快，支持增量生成 主题丰富: 有众多优秀的主题可选择 为什么选择 Stellar 主题？Stellar 是我见过的最优雅的 Hexo 主题之一： 设计美观: 现代化的设计风格，视觉效果出色 功能丰富: 内置搜索、评论、统计等功能 移动友好: 完美的响应式设计 配置灵活: 高度可定制化 持续维护: 作者 @xaoxuu 持续更新 🛠️ 搭建过程1. 环境准备首先确保系统已安装 Node.js 和 Git： # 检查 Node.js 版本node --version# 检查 npm 版本 npm --version# 检查 Git 版本git --version 2. 安装 Hexo# 全局安装 Hexo CLInpm install -g hexo-cli# 初始化博客项目hexo init my-blogcd my-blog# 安装依赖npm install 3. 安装 Stellar 主题# 安装 Stellar 主题npm install hexo-theme-stellar# 或者使用 Git 克隆（推荐）git clone https://github.com/xaoxuu/hexo-theme-stellar.git themes/stellar 4. 基础配置修改根目录下的 _config.yml： # 站点信息title: nash635subtitle: For all time, always.description: 记录生活，分享技术，探索未知的可能性keywords: 技术博客,编程,开发,生活记录author: nash635language: zh-CNtimezone: Asia/Shanghai# URL 配置url: https://nash635.github.iopermalink: :year/:month/:day/:title/# 主题配置theme: stellar 5. Stellar 主题配置创建 _config.stellar.yml 文件进行主题配置： # 网站 Logologo: title: nash635 subtitle: For all time, always.# 导航菜单menubar: columns: 4 items: - name: 博客 icon: solar:notebook-bold-duotone url: / - name: 项目 icon: solar:code-bold-duotone url: /wiki/ - name: 标签 icon: solar:tag-bold-duotone url: /tags/ - name: 关于 icon: solar:user-bold-duotone url: /about/# 搜索功能search: service: local_search local_search: field: all path: /search.json 🎨 定制优化1. 个性化配置根据个人喜好调整主题配置： # 首页显示home: title: 欢迎，旅行者 subtitle: 在这里记录生活点滴，分享技术心得# 文章页面article: sidebar: position: right items: - widget: toc - widget: related_posts# 页脚配置footer: copyright: | 本站由 @nash635 使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar) 创建 2. 添加插件安装常用插件增强功能： # 搜索插件npm install hexo-generator-search --save# JSON 内容生成器npm install hexo-generator-json-content --save# 站点地图npm install hexo-generator-sitemap --save# RSS 订阅npm install hexo-generator-feed --save 3. 创建页面创建必要的页面： # 关于页面hexo new page about# 标签页面hexo new page tags# 分类页面 hexo new page categories# 归档页面hexo new page archives 🚀 部署优化1. GitHub Pages 部署配置 GitHub Actions 自动部署： # .github/workflows/deploy.ymlname: Deploy to GitHub Pageson: push: branches: [ main ]jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: 16 - name: Install dependencies run: npm install - name: Generate static files run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $ secrets.GITHUB_TOKEN publish_dir: ./public 2. 性能优化启用压缩和缓存： # _config.yml# 压缩 HTMLminify: html: enable: true # 启用 gzip 压缩compress: html: true css: true js: true 📊 效果展示经过配置优化后，博客具备了以下特性： ✅ 响应式设计: 完美适配桌面端和移动端 ✅ 搜索功能: 支持本地搜索，快速查找内容 ✅ SEO 友好: 良好的搜索引擎优化 ✅ 加载迅速: 静态文件，访问速度快 ✅ 功能丰富: 标签分类、归档、评论等功能完善 🎯 后续计划博客搭建完成后，还有一些优化工作要做： 近期计划 配置评论系统（GiscusWaline） 添加网站统计（Google Analytics） 优化 SEO 配置 添加 PWA 支持 长期计划 建立友链网络 开发自定义插件 添加更多实用工具页面 集成 API 服务 💡 经验总结通过这次博客搭建，我总结了几点经验： 选择合适的工具: 根据需求选择技术栈，不要盲目追新 注重用户体验: 页面加载速度和移动端适配很重要 持续优化: 博客是一个长期项目，需要不断完善 内容为王: 再好的工具也要有优质的内容支撑 🔗 参考资源 Hexo 官方文档 Stellar 主题文档 GitHub Pages 文档 Markdown 语法指南 博客的搭建只是开始，接下来要做的是持续创作优质内容。如果你也想搭建类似的博客，希望这篇文章能对你有所帮助！ 有任何问题欢迎在评论区交流～ 🤝","tags":["stellar","博客搭建","hexo","静态网站","github-pages"],"categories":["技术分享"]},{"title":"Hello World - 我的技术博客正式上线","path":"/2025/07/24/Hello-World/","content":"Hello World! 🌍欢迎来到我的个人博客！经过精心设计和配置，这个基于 Hexo 和 Stellar 主题的技术博客终于与大家见面了。 For all time, always. 🎯 关于这个博客这个博客的诞生源于我对知识分享的热爱和对技术探索的渴望。在这里，我将记录： 📚 技术探索 分布式系统: 架构设计、一致性算法、微服务实践 深度学习: 模型训练、算法优化、工程实践 算法工程: 数据结构、算法设计、性能优化 开发工具: 效率工具、开发环境、最佳实践 🌱 成长记录 学习笔记: 新技术的学习心得和总结 项目实战: 个人项目的开发过程和思考 读书心得: 技术书籍和人文著作的感悟 生活感悟: 工作生活中的思考和体会 �️ 博客架构这个博客采用现代化的技术栈： 生成器: Hexo 7.3.0主题: Stellar 1.33.1部署: GitHub PagesCDN: jsDelivr搜索: 本地搜索评论: 待配置统计: 待配置 🎨 设计理念参考了 xaoxuu.com 的设计风格，追求： 简洁美观: 清爽的界面设计，专注内容阅读 移动优先: 完美适配各种设备屏幕 快速加载: 优化资源加载，提升用户体验 易于导航: 清晰的分类结构，便于内容发现 🗺️ 站点导航博客包含以下主要板块： 博客：最新文章和技术分享 项目：开源项目和个人作品展示 探索：学习笔记和思考记录 社交：友情链接和交流平台 专栏：系列文章和深度内容 标签：按标签浏览文章 分类：按分类查看内容 归档：时间线浏览历史文章 关于：个人介绍和联系方式 � 未来计划接下来，我计划在博客中发布以下内容： 近期目标 完善评论和统计系统 添加更多实用工具页面 优化 SEO 和站点性能 建立友链社区 内容规划 分布式系统设计 系列文章 深度学习实践 项目记录 算法与数据结构 专题总结 开发工具箱 效率提升指南 💬 交流与反馈这个博客不仅是我的技术记录平台，也希望成为技术交流的小天地。如果你： 对文章内容有疑问或建议 想要交流技术问题 希望申请友链合作 发现了网站问题 欢迎通过以下方式联系我： GitHub: @nash635 Email: nash635@example.com 留言: 在文章下方评论区留言 🙏 致谢感谢以下开源项目和作者： Hexo - 快速、简洁且高效的博客框架 Stellar - 优雅的 Hexo 主题 @xaoxuu - Stellar 主题作者 GitHub Pages - 免费的静态网站托管 🎉 开始探索博客已经准备就绪，让我们一起开启这段技术探索之旅吧！ 如果你觉得这个博客对你有帮助，欢迎： ⭐ 给 项目仓库 点个 Star 🔗 推荐给更多朋友 💬 留言交流你的想法 感谢你的访问，期待与你的交流！ 😊 第一篇文章总是特别的，它标志着一个新的开始。愿这个博客能够记录下我的成长轨迹，也能为访问的朋友们带来一些价值。","tags":["hello","world","stellar","博客搭建"],"categories":["生活"]},{"path":"/img/README.html","content":"图片资源说明这个目录用于存放博客相关的图片资源： favicon.png - 网站图标 avatar.png - 个人头像 og-image.png - Open Graph 分享图片 logo.png - 网站 Logo 请根据需要添加相应的图片文件。"},{"title":"专栏","path":"/topic/index.html","content":"专栏这里汇集了我按主题整理的文章系列和深度内容。 技术专栏🖥️ 分布式系统设计深入探讨分布式系统的设计原理、架构模式和实践经验。 计划文章: 分布式系统基础概念 CAP 定理的实际应用 分布式一致性算法解析 微服务架构最佳实践 🤖 深度学习实践从理论到实践，记录深度学习的学习心得和项目经验。 计划文章: 神经网络基础回顾 卷积神经网络实战 自然语言处理技术 模型部署与优化 ⚡ 算法与数据结构系统性地整理算法学习笔记和解题思路。 计划文章: 常用数据结构总结 动态规划专题 图算法深入解析 算法复杂度分析 生活专栏📖 读书笔记分享阅读技术书籍和人文著作的心得体会。 🌱 成长思考记录个人成长过程中的思考和感悟。 专栏文章会持续更新，每个系列都会有详细的目录和进度跟踪。"},{"title":"项目","path":"/wiki/index.html","content":"我的项目这里展示我参与开发和维护的开源项目以及个人作品。 开源项目正在开发中…目前正在整理和完善项目文档，敬请期待。 个人作品博客网站 描述: 基于 Hexo + Stellar 主题的个人博客 技术栈: Hexo, Stellar Theme, GitHub Pages 功能: 文章发布、标签分类、搜索功能、响应式设计 计划中的项目 技术文档站点 开源工具开发 算法可视化项目 如果您对任何项目感兴趣或有合作想法，欢迎通过邮件或 GitHub 联系我。"},{"title":"探索","path":"/notes/index.html","content":"探索笔记这里记录我在学习和探索过程中的思考、发现和总结。 技术探索分布式系统 微服务架构设计模式 分布式一致性算法 容器化与云原生技术 深度学习 神经网络架构优化 模型训练技巧 AI工程实践 算法工程 数据结构与算法优化 系统设计思考 性能调优经验 学习资源推荐书籍 《设计数据密集型应用》 《深度学习》 《算法导论》 在线资源 CS自学指南 机器学习年鉴 系统设计入门 思考记录最近在思考的问题 如何平衡技术深度与广度？ 开源项目的可持续发展模式 AI时代的工程师职业发展 探索永无止境，记录让思考更有价值。"},{"title":"关于我","path":"/about/index.html","content":"关于我你好！我是 nash635，欢迎来到我的个人博客！ 👋 For all time, always. 🙋‍♂️ 个人介绍我是一名热爱技术的开发者。喜欢探索新技术，记录学习过程，分享技术经验与生活感悟。 相信技术改变世界，也相信记录让思考更有价值。 💻 技术栈后端开发 语言: Python, Java, Go 框架: Spring Boot, FastAPI, Gin 数据库: MySQL, PostgreSQL, Redis, MongoDB 分布式系统 消息队列: RabbitMQ, Apache Kafka 服务治理: Spring Cloud, Dubbo 容器化: Docker, Kubernetes 微服务: Istio, Envoy 深度学习 框架: PyTorch, TensorFlow 领域: 计算机视觉, 自然语言处理 工具: Jupyter, MLflow, Weights Biases 算法工程 数据结构与算法: 扎实的理论基础 系统设计: 大规模系统架构设计 性能优化: 代码优化与系统调优 📝 博客内容在这个博客中，我会分享： 技术文章: 深入的技术教程和实践经验 学习笔记: 新技术的学习心得和总结 项目记录: 个人项目的开发过程和思考 读书笔记: 技术书籍和人文著作的读后感 生活感悟: 工作生活中的思考和体会 🎯 个人理念 持续学习: 保持好奇心，拥抱新技术 深度思考: 不仅要知其然，更要知其所以然 分享交流: 知识因分享而更有价值 实践至上: 理论结合实践，用项目检验学习成果 📫 联系方式 GitHub: nash635 Email: nash635@example.com 博客: nash635.github.io 🔗 友情链接欢迎访问我的 友链页面 发现更多优秀的博客！ 感谢您的访问！如果您觉得我的内容对您有帮助，欢迎留言交流或分享给更多朋友。 让我们一起在技术的道路上前行！ 🚀 📫 联系方式如果您有任何问题或想要交流，欢迎通过以下方式联系我： GitHub: nash635 Email: shaj24@mails.tsinghua.edu.cn 感谢您的访问！希望我的分享能对您有所帮助。"}]